goja
====

Реализация ECMAScript 5.1(+) на Go.

[![Go Reference](https://pkg.go.dev/badge/github.com/dop251/goja.svg)](https://pkg.go.dev/github.com/dop251/goja)

> **Примечание об этом форке**: Этот форк включает расширенную поддержку отладки для Goja. Мы попытались внести эти изменения в основной проект через минимальный pull request, но из-за объема и времени изменений он не был принят в тот момент. Поскольку поддержка отладки критически важна для наших проектов и для улучшения качества интеграции, мы продолжили разработку в этом форке. Мы глубоко ценим отличную работу dop251 и всего проекта Goja. Мы понимаем, что интеграция существенных функций отладки требует тщательного рассмотрения, и уважаем решение мейнтейнера. Этот форк остается доступным для тех, кому нужны возможности отладки прямо сейчас. Если dop251 решит объединить эти изменения с основным проектом в будущем, это принесет нам большую радость и удовлетворение увидеть, как наши вклады приносят пользу более широкому сообществу Goja.
>
> **Использование этого форка**: Чтобы использовать этот форк в вашем Go проекте, добавьте следующую директиву replace в ваш файл `go.mod`:
> ```
> replace github.com/dop251/goja => github.com/arturoeanton/goja latest
> ```

Goja - это реализация ECMAScript 5.1 на чистом Go с акцентом на соответствие стандартам и
производительность.

Этот проект был во многом вдохновлен [otto](https://github.com/robertkrimen/otto).

Минимальная требуемая версия Go - 1.20.

Возможности
-----------

 * Полная поддержка ECMAScript 5.1 (включая регулярные выражения и строгий режим).
 * Проходит почти все [тесты tc39](https://github.com/tc39/test262) для реализованных на данный момент функций. Цель -
   пройти все тесты. См. .tc39_test262_checkout.sh для последнего рабочего commit id.
 * Способен запускать Babel, компилятор TypeScript и практически все, написанное на ES5.
 * Sourcemaps.
 * Большая часть функциональности ES6, все еще в процессе разработки, см. https://github.com/dop251/goja/milestone/1?closed=1

Известные несовместимости и предостережения
-------------------------------------------

### WeakMap
WeakMap реализован путем встраивания ссылок на значения в ключи. Это означает, что пока
ключ достижим, все значения, связанные с ним в любых weak map, также остаются достижимыми и поэтому
не могут быть собраны сборщиком мусора, даже если они не имеют других ссылок, даже после того, как WeakMap исчез.
Ссылка на значение удаляется либо когда ключ явно удаляется из WeakMap, либо когда
ключ становится недостижимым.

Для иллюстрации:

```javascript
var m = new WeakMap();
var key = {};
var value = {/* очень большой объект */};
m.set(key, value);
value = undefined;
m = undefined; // Значение НЕ становится доступным для сборки мусора в этот момент
key = undefined; // Теперь становится
// m.delete(key); // Это тоже сработало бы
```

Причина в ограничении среды выполнения Go. На момент написания (версия 1.15) установка финализатора
на объект, который является частью цикла ссылок, делает весь цикл недоступным для сборки мусора. Решение
выше - единственный разумный способ, который я могу придумать без использования финализаторов. Это третья попытка
(см. https://github.com/dop251/goja/issues/250 и https://github.com/dop251/goja/issues/199 для подробностей).

Обратите внимание, что это не влияет на логику приложения, но может вызвать более высокое потребление памяти, чем ожидалось.

### WeakRef и FinalizationRegistry
По причине, упомянутой выше, реализация WeakRef и FinalizationRegistry не представляется возможной на данном этапе.

### JSON
`JSON.parse()` использует стандартную библиотеку Go, которая работает в UTF-8. Поэтому он не может правильно анализировать поврежденные суррогатные пары UTF-16, например:

```javascript
JSON.parse(`"\\uD800"`).charCodeAt(0).toString(16) // возвращает "fffd" вместо "d800"
```

### Date
Преобразование календарной даты в временную метку эпохи использует стандартную библиотеку Go, которая использует `int`, а не `float` согласно
спецификации ECMAScript. Это означает, что если вы передаете аргументы, которые переполняют int, в конструктор `Date()` или если происходит
целочисленное переполнение, результат будет неверным, например:

```javascript
Date.UTC(1970, 0, 1, 80063993375, 29, 1, -288230376151711740) // возвращает 29256 вместо 29312
```

FAQ
---

### Насколько это быстро?

Хотя это быстрее многих реализаций скриптовых языков на Go, которые я видел
(например, в среднем в 6-7 раз быстрее otto), это не
замена V8 или SpiderMonkey или любого другого универсального JavaScript движка.
Вы можете найти некоторые бенчмарки [здесь](https://github.com/dop251/goja/issues/2).

### Почему я должен использовать это вместо обертки V8?

Это сильно зависит от вашего сценария использования. Если большая часть работы выполняется в javascript
(например, криптография или любые другие тяжелые вычисления), вам определенно лучше с V8.

Если вам нужен скриптовый язык, который управляет движком, написанным на Go, так что
вам нужно часто делать вызовы между Go и javascript, передавая сложные структуры данных,
то накладные расходы cgo могут перевесить преимущества более быстрого javascript движка.

Поскольку он написан на чистом Go, нет зависимостей cgo, его очень легко собрать, и
он должен работать на любой платформе, поддерживаемой Go.

Он дает вам гораздо лучший контроль над средой выполнения, поэтому может быть полезен для исследований.

### Безопасен ли он для горутин?

Нет. Экземпляр goja.Runtime может использоваться только одной горутиной
за раз. Вы можете создавать столько экземпляров Runtime, сколько хотите, но
невозможно передавать значения объектов между рантаймами.

### Где setTimeout()/setInterval()?

setTimeout() и setInterval() - это распространенные функции для обеспечения параллельного выполнения в средах ECMAScript, но эти две функции не являются частью стандарта ECMAScript.
Браузеры и NodeJS просто предоставляют похожие, но не идентичные функции. Хост-приложение должно контролировать среду для параллельного выполнения, например, цикл событий, и предоставлять функциональность коду скрипта.

Есть [отдельный проект](https://github.com/dop251/goja_nodejs), направленный на предоставление некоторой функциональности NodeJS,
и он включает цикл событий.

### Можете ли вы реализовать (функцию X из ES6 или выше)?

Я буду добавлять функции в порядке их зависимостей и так быстро, как позволит время. Пожалуйста, не спрашивайте
о сроках. Функции, которые открыты в [вехе](https://github.com/dop251/goja/milestone/1), либо находятся в процессе разработки,
либо будут разработаны следующими.

Текущая работа ведется в отдельных ветках функций, которые объединяются в master, когда это уместно.
Каждый коммит в этих ветках представляет относительно стабильное состояние (т.е. компилируется и проходит все включенные тесты tc39),
однако, поскольку версия тестов tc39, которую я использую, довольно старая, она может быть не так хорошо протестирована, как функциональность ES5.1. Поскольку между ревизиями ECMAScript (обычно) нет серьезных ломающих изменений,
это не должно сломать ваш существующий код. Вам рекомендуется попробовать и сообщить о найденных ошибках. Пожалуйста, не отправляйте исправления без предварительного обсуждения, так как код может измениться в это время.

### Как я могу внести свой вклад?

Перед отправкой pull request убедитесь, что:

- Вы следовали стандарту ECMA настолько близко, насколько это возможно. Если добавляете новую функцию, убедитесь, что вы прочитали спецификацию,
не основывайтесь только на паре примеров, которые хорошо работают.
- Ваше изменение не оказывает значительного негативного влияния на производительность (если это не исправление ошибки и неизбежно)
- Оно проходит все соответствующие тесты tc39.

Текущий статус
--------------

 * В API не должно быть ломающих изменений, однако оно может быть расширено.
 * Отсутствует некоторая функциональность AnnexB.

Базовый пример
--------------

Запустите JavaScript и получите значение результата.

```go
vm := goja.New()
v, err := vm.RunString("2 + 2")
if err != nil {
    panic(err)
}
if num := v.Export().(int64); num != 4 {
    panic(num)
}
```

Передача значений в JS
----------------------
Любое значение Go может быть передано в JS с помощью метода Runtime.ToValue(). См. [документацию](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) метода для подробностей.

Экспорт значений из JS
----------------------
Значение JS может быть экспортировано в его представление Go по умолчанию с помощью метода Value.Export().

В качестве альтернативы оно может быть экспортировано в конкретную переменную Go с помощью метода [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo).

В рамках одной операции экспорта один и тот же Object будет представлен одним и тем же значением Go (либо той же map, slice или
указателем на ту же struct). Это включает циклические объекты и делает возможным их экспорт.

Вызов функций JS из Go
----------------------
Есть 2 подхода:

- Используя [AssertFunction()](https://pkg.go.dev/github.com/dop251/goja#AssertFunction):
```go
const SCRIPT = `
function sum(a, b) {
    return +a + b;
}
`

vm := goja.New()
_, err := vm.RunString(SCRIPT)
if err != nil {
    panic(err)
}
sum, ok := goja.AssertFunction(vm.Get("sum"))
if !ok {
    panic("Not a function")
}

res, err := sum(goja.Undefined(), vm.ToValue(40), vm.ToValue(2))
if err != nil {
    panic(err)
}
fmt.Println(res)
// Output: 42
```
- Используя [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo):
```go
const SCRIPT = `
function sum(a, b) {
    return +a + b;
}
`

vm := goja.New()
_, err := vm.RunString(SCRIPT)
if err != nil {
    panic(err)
}

var sum func(int, int) int
err = vm.ExportTo(vm.Get("sum"), &sum)
if err != nil {
    panic(err)
}

fmt.Println(sum(40, 2)) // примечание, значение _this_ в функции будет undefined.
// Output: 42
```

Первый более низкоуровневый и позволяет указать значение _this_, в то время как второй делает функцию похожей на
обычную функцию Go.

Сопоставление имен полей и методов структур
--------------------------------------------
По умолчанию имена передаются как есть, что означает, что они капитализированы. Это не соответствует
стандартному соглашению об именовании JavaScript, поэтому, если вам нужно сделать ваш JS-код более естественным или если вы
работаете с библиотекой третьей стороны, вы можете использовать [FieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#FieldNameMapper):

```go
vm := goja.New()
vm.SetFieldNameMapper(TagFieldNameMapper("json", true))
type S struct {
    Field int `json:"field"`
}
vm.Set("s", S{Field: 42})
res, _ := vm.RunString(`s.field`) // без маппера это было бы s.Field
fmt.Println(res.Export())
// Output: 42
```

Есть два стандартных маппера: [TagFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#TagFieldNameMapper) и
[UncapFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#UncapFieldNameMapper), или вы можете использовать свою собственную реализацию.

Нативные конструкторы
---------------------

Чтобы реализовать функцию-конструктор в Go, используйте `func (goja.ConstructorCall) *goja.Object`.
См. документацию [Runtime.ToValue()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) для подробностей.

Регулярные выражения
--------------------

Goja использует встроенную библиотеку regexp Go, где это возможно, в противном случае использует [regexp2](https://github.com/dlclark/regexp2).

Исключения
----------

Любое исключение, брошенное в JavaScript, возвращается как ошибка типа *Exception. Можно извлечь брошенное значение
с помощью метода Value():

```go
vm := goja.New()
_, err := vm.RunString(`

throw("Test");

`)

if jserr, ok := err.(*Exception); ok {
    if jserr.Value().Export() != "Test" {
        panic("wrong value")
    }
} else {
    panic("wrong type")
}
```

Если нативная функция Go паникует со значением Value, оно бросается как исключение Javascript (и поэтому может быть поймано):

```go
var vm *Runtime

func Test() {
    panic(vm.ToValue("Error"))
}

vm = goja.New()
vm.Set("Test", Test)
_, err := vm.RunString(`

try {
    Test();
} catch(e) {
    if (e !== "Error") {
        throw e;
    }
}

`)

if err != nil {
    panic(err)
}
```

Прерывание
----------

```go
func TestInterrupt(t *testing.T) {
    const SCRIPT = `
    var i = 0;
    for (;;) {
        i++;
    }
    `

    vm := goja.New()
    time.AfterFunc(200 * time.Millisecond, func() {
        vm.Interrupt("halt")
    })

    _, err := vm.RunString(SCRIPT)
    if err == nil {
        t.Fatal("Err is nil")
    }
    // err имеет тип *InterruptError, и его метод Value() возвращает то, что было передано в vm.Interrupt()
}
```

Совместимость с NodeJS
----------------------

Есть [отдельный проект](https://github.com/dop251/goja_nodejs), направленный на предоставление некоторой функциональности NodeJS.