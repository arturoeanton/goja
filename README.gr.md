goja
====

Υλοποίηση ECMAScript 5.1(+) σε Go.

[![Go Reference](https://pkg.go.dev/badge/github.com/dop251/goja.svg)](https://pkg.go.dev/github.com/dop251/goja)

> **Σημείωση σχετικά με αυτό το fork**: Αυτό το fork περιλαμβάνει εκτεταμένη υποστήριξη debugging για το Goja. Προσπαθήσαμε να συνεισφέρουμε αυτές τις αλλαγές στο αρχικό έργο μέσω ενός ελάχιστου pull request, αλλά λόγω του εύρους και του χρονισμού των αλλαγών, δεν έγινε αποδεκτό εκείνη τη στιγμή. Καθώς η υποστήριξη debugging είναι κρίσιμη για τα έργα μας και για τη βελτίωση της ποιότητας των ενσωματώσεων, συνεχίσαμε την ανάπτυξη σε αυτό το fork. Εκτιμούμε βαθιά την εξαιρετική δουλειά του dop251 και ολόκληρου του έργου Goja. Κατανοούμε ότι η ενσωμάτωση ουσιαστικών λειτουργιών debugging απαιτεί προσεκτική εξέταση και σεβόμαστε την απόφαση του συντηρητή. Αυτό το fork παραμένει διαθέσιμο για όσους χρειάζονται δυνατότητες debugging τώρα. Εάν ο dop251 αποφασίσει να συγχωνεύσει αυτές τις αλλαγές με το upstream έργο στο μέλλον, θα μας φέρει μεγάλη χαρά και ικανοποίηση να δούμε τις συνεισφορές μας να ωφελούν την ευρύτερη κοινότητα του Goja.
>
> **Χρήση αυτού του fork**: Για να χρησιμοποιήσετε αυτό το fork στο Go project σας, προσθέστε την ακόλουθη οδηγία replace στο αρχείο `go.mod` σας:
> ```
> replace github.com/dop251/goja => github.com/arturoeanton/goja latest
> ```

Το Goja είναι μια υλοποίηση του ECMAScript 5.1 σε καθαρή Go με έμφαση στη συμμόρφωση με τα πρότυπα και
την απόδοση.

Αυτό το έργο εμπνεύστηκε σε μεγάλο βαθμό από το [otto](https://github.com/robertkrimen/otto).

Η ελάχιστη απαιτούμενη έκδοση Go είναι 1.20.

Χαρακτηριστικά
--------------

 * Πλήρης υποστήριξη ECMAScript 5.1 (συμπεριλαμβανομένων regex και strict mode).
 * Περνάει σχεδόν όλα τα [tc39 tests](https://github.com/tc39/test262) για τις λειτουργίες που έχουν υλοποιηθεί μέχρι τώρα. Ο στόχος είναι να
   περάσει όλα. Δείτε το .tc39_test262_checkout.sh για το τελευταίο λειτουργικό commit id.
 * Ικανό να τρέξει Babel, Typescript compiler και σχεδόν οτιδήποτε γραμμένο σε ES5.
 * Sourcemaps.
 * Το μεγαλύτερο μέρος της λειτουργικότητας ES6, ακόμη σε εξέλιξη, δείτε https://github.com/dop251/goja/milestone/1?closed=1

Γνωστές ασυμβατότητες και προειδοποιήσεις
-----------------------------------------

### WeakMap
Το WeakMap υλοποιείται ενσωματώνοντας αναφορές στις τιμές μέσα στα κλειδιά. Αυτό σημαίνει ότι όσο
το κλειδί είναι προσβάσιμο, όλες οι τιμές που σχετίζονται με αυτό σε οποιοδήποτε weak map παραμένουν επίσης προσβάσιμες και επομένως
δεν μπορούν να συλλεχθούν από τον garbage collector ακόμη και αν δεν αναφέρονται αλλιώς, ακόμη και μετά την εξαφάνιση του WeakMap.
Η αναφορά στην τιμή απορρίπτεται είτε όταν το κλειδί αφαιρείται ρητά από το WeakMap είτε όταν το
κλειδί γίνεται μη προσβάσιμο.

Για να το απεικονίσουμε:

```javascript
var m = new WeakMap();
var key = {};
var value = {/* ένα πολύ μεγάλο αντικείμενο */};
m.set(key, value);
value = undefined;
m = undefined; // Η τιμή ΔΕΝ γίνεται συλλέξιμη από τον garbage collector σε αυτό το σημείο
key = undefined; // Τώρα γίνεται
// m.delete(key); // Αυτό θα λειτουργούσε επίσης
```

Ο λόγος είναι ο περιορισμός του Go runtime. Κατά τη στιγμή της συγγραφής (έκδοση 1.15) η ύπαρξη ενός finalizer
σε ένα αντικείμενο που είναι μέρος ενός κύκλου αναφοράς καθιστά ολόκληρο τον κύκλο μη συλλέξιμο από τον garbage collector. Η λύση
παραπάνω είναι ο μόνος λογικός τρόπος που μπορώ να σκεφτώ χωρίς να εμπλέκονται finalizers. Αυτή είναι η τρίτη προσπάθεια
(δείτε https://github.com/dop251/goja/issues/250 και https://github.com/dop251/goja/issues/199 για περισσότερες λεπτομέρειες).

Σημειώστε ότι αυτό δεν έχει καμία επίδραση στη λογική της εφαρμογής, αλλά μπορεί να προκαλέσει υψηλότερη από την αναμενόμενη χρήση μνήμης.

### WeakRef και FinalizationRegistry
Για τον λόγο που αναφέρθηκε παραπάνω, η υλοποίηση των WeakRef και FinalizationRegistry δεν φαίνεται να είναι δυνατή σε αυτό το στάδιο.

### JSON
Το `JSON.parse()` χρησιμοποιεί την τυπική βιβλιοθήκη Go που λειτουργεί σε UTF-8. Επομένως, δεν μπορεί να αναλύσει σωστά σπασμένα ζεύγη surrogate UTF-16, για παράδειγμα:

```javascript
JSON.parse(`"\\uD800"`).charCodeAt(0).toString(16) // επιστρέφει "fffd" αντί για "d800"
```

### Date
Η μετατροπή από ημερομηνία ημερολογίου σε epoch timestamp χρησιμοποιεί την τυπική βιβλιοθήκη Go που χρησιμοποιεί `int`, αντί για `float` σύμφωνα με την
προδιαγραφή ECMAScript. Αυτό σημαίνει ότι αν περάσετε ορίσματα που υπερχειλίζουν το int στον κατασκευαστή `Date()` ή αν υπάρχει
υπερχείλιση ακεραίων, το αποτέλεσμα θα είναι λανθασμένο, για παράδειγμα:

```javascript
Date.UTC(1970, 0, 1, 80063993375, 29, 1, -288230376151711740) // επιστρέφει 29256 αντί για 29312
```

Συχνές Ερωτήσεις
----------------

### Πόσο γρήγορο είναι;

Αν και είναι ταχύτερο από πολλές υλοποιήσεις γλωσσών scripting σε Go που έχω δει
(για παράδειγμα είναι 6-7 φορές ταχύτερο από το otto κατά μέσο όρο) δεν είναι
αντικατάσταση για το V8 ή το SpiderMonkey ή οποιοδήποτε άλλο γενικής χρήσης JavaScript engine.
Μπορείτε να βρείτε μερικά benchmarks [εδώ](https://github.com/dop251/goja/issues/2).

### Γιατί θα ήθελα να το χρησιμοποιήσω αντί για ένα V8 wrapper;

Εξαρτάται σε μεγάλο βαθμό από το σενάριο χρήσης σας. Αν το μεγαλύτερο μέρος της δουλειάς γίνεται σε javascript
(για παράδειγμα crypto ή οποιοσδήποτε άλλος βαρύς υπολογισμός) σίγουρα είστε καλύτερα με το V8.

Αν χρειάζεστε μια γλώσσα scripting που οδηγεί μια μηχανή γραμμένη σε Go έτσι ώστε
να χρειάζεται να κάνετε συχνές κλήσεις μεταξύ Go και javascript περνώντας πολύπλοκες δομές δεδομένων
τότε το cgo overhead μπορεί να υπερισχύσει των πλεονεκτημάτων του να έχετε ένα ταχύτερο javascript engine.

Επειδή είναι γραμμένο σε καθαρή Go δεν υπάρχουν εξαρτήσεις cgo, είναι πολύ εύκολο να χτιστεί και
θα πρέπει να τρέχει σε οποιαδήποτε πλατφόρμα που υποστηρίζεται από το Go.

Σας δίνει πολύ καλύτερο έλεγχο του περιβάλλοντος εκτέλεσης, οπότε μπορεί να είναι χρήσιμο για έρευνα.

### Είναι ασφαλές για goroutines;

Όχι. Μια παρουσία του goja.Runtime μπορεί να χρησιμοποιηθεί μόνο από μία goroutine
κάθε φορά. Μπορείτε να δημιουργήσετε όσες παρουσίες Runtime θέλετε αλλά
δεν είναι δυνατό να περάσετε τιμές αντικειμένων μεταξύ runtimes.

### Πού είναι το setTimeout()/setInterval();

Τα setTimeout() και setInterval() είναι κοινές συναρτήσεις για την παροχή ταυτόχρονης εκτέλεσης σε περιβάλλοντα ECMAScript, αλλά οι δύο συναρτήσεις δεν είναι μέρος του προτύπου ECMAScript.
Οι browsers και το NodeJS απλώς παρέχουν παρόμοιες, αλλά όχι πανομοιότυπες, συναρτήσεις. Η εφαρμογή φιλοξενίας πρέπει να ελέγχει το περιβάλλον για ταυτόχρονη εκτέλεση, π.χ. ένα event loop, και να παρέχει τη λειτουργικότητα στον κώδικα script.

Υπάρχει ένα [ξεχωριστό έργο](https://github.com/dop251/goja_nodejs) που στοχεύει στην παροχή κάποιας λειτουργικότητας NodeJS,
και περιλαμβάνει ένα event loop.

### Μπορείτε να υλοποιήσετε (χαρακτηριστικό X από ES6 ή νεότερο);

Θα προσθέτω χαρακτηριστικά με τη σειρά εξάρτησής τους και όσο γρήγορα επιτρέπει ο χρόνος. Παρακαλώ μην ζητάτε
ETAs. Τα χαρακτηριστικά που είναι ανοιχτά στο [milestone](https://github.com/dop251/goja/milestone/1) είτε βρίσκονται σε εξέλιξη
είτε θα δουλευτούν στη συνέχεια.

Η συνεχιζόμενη εργασία γίνεται σε ξεχωριστά branches χαρακτηριστικών που συγχωνεύονται στο master όταν είναι κατάλληλο.
Κάθε commit σε αυτά τα branches αντιπροσωπεύει μια σχετικά σταθερή κατάσταση (δηλαδή μεταγλωττίζεται και περνάει όλα τα ενεργοποιημένα tc39 tests),
ωστόσο επειδή η έκδοση των tc39 tests που χρησιμοποιώ είναι αρκετά παλιά, μπορεί να μην είναι τόσο καλά δοκιμασμένη όσο η λειτουργικότητα ES5.1. Επειδή δεν υπάρχουν (συνήθως) μεγάλες αλλαγές που σπάνε τη συμβατότητα μεταξύ των αναθεωρήσεων ECMAScript
δεν θα πρέπει να σπάσει τον υπάρχοντα κώδικά σας. Ενθαρρύνεστε να το δοκιμάσετε και να αναφέρετε τυχόν σφάλματα που βρίσκετε. Παρακαλώ μην υποβάλετε διορθώσεις χωρίς να το συζητήσετε πρώτα, καθώς ο κώδικας θα μπορούσε να αλλάξει στο μεταξύ.

### Πώς συνεισφέρω;

Πριν υποβάλετε ένα pull request βεβαιωθείτε ότι:

- Ακολουθήσατε το πρότυπο ECMA όσο το δυνατόν πιο κοντά. Αν προσθέτετε ένα νέο χαρακτηριστικό βεβαιωθείτε ότι έχετε διαβάσει την προδιαγραφή,
μην το βασίζετε απλώς σε μερικά παραδείγματα που λειτουργούν καλά.
- Η αλλαγή σας δεν έχει σημαντική αρνητική επίδραση στην απόδοση (εκτός αν είναι διόρθωση σφάλματος και είναι αναπόφευκτη)
- Περνάει όλα τα σχετικά tc39 tests.

Τρέχουσα Κατάσταση
------------------

 * Δεν θα πρέπει να υπάρχουν αλλαγές που σπάνε τη συμβατότητα στο API, ωστόσο μπορεί να επεκταθεί.
 * Λείπει κάποια από τη λειτουργικότητα AnnexB.

Βασικό Παράδειγμα
-----------------

Εκτελέστε JavaScript και λάβετε την τιμή αποτελέσματος.

```go
vm := goja.New()
v, err := vm.RunString("2 + 2")
if err != nil {
    panic(err)
}
if num := v.Export().(int64); num != 4 {
    panic(num)
}
```

Περνώντας Τιμές στο JS
----------------------
Οποιαδήποτε τιμή Go μπορεί να περάσει στο JS χρησιμοποιώντας τη μέθοδο Runtime.ToValue(). Δείτε την [τεκμηρίωση](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) της μεθόδου για περισσότερες λεπτομέρειες.

Εξαγωγή Τιμών από JS
--------------------
Μια τιμή JS μπορεί να εξαχθεί στην προεπιλεγμένη αναπαράστασή της στο Go χρησιμοποιώντας τη μέθοδο Value.Export().

Εναλλακτικά μπορεί να εξαχθεί σε μια συγκεκριμένη μεταβλητή Go χρησιμοποιώντας τη μέθοδο [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo).

Μέσα σε μια μόνο λειτουργία εξαγωγής το ίδιο Object θα αναπαρίσταται από την ίδια τιμή Go (είτε το ίδιο map, slice ή
έναν δείκτη στο ίδιο struct). Αυτό περιλαμβάνει κυκλικά αντικείμενα και καθιστά δυνατή την εξαγωγή τους.

Κλήση συναρτήσεων JS από Go
----------------------------
Υπάρχουν 2 προσεγγίσεις:

- Χρησιμοποιώντας [AssertFunction()](https://pkg.go.dev/github.com/dop251/goja#AssertFunction):
```go
const SCRIPT = `
function sum(a, b) {
    return +a + b;
}
`

vm := goja.New()
_, err := vm.RunString(SCRIPT)
if err != nil {
    panic(err)
}
sum, ok := goja.AssertFunction(vm.Get("sum"))
if !ok {
    panic("Not a function")
}

res, err := sum(goja.Undefined(), vm.ToValue(40), vm.ToValue(2))
if err != nil {
    panic(err)
}
fmt.Println(res)
// Output: 42
```
- Χρησιμοποιώντας [Runtime.ExportTo()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ExportTo):
```go
const SCRIPT = `
function sum(a, b) {
    return +a + b;
}
`

vm := goja.New()
_, err := vm.RunString(SCRIPT)
if err != nil {
    panic(err)
}

var sum func(int, int) int
err = vm.ExportTo(vm.Get("sum"), &sum)
if err != nil {
    panic(err)
}

fmt.Println(sum(40, 2)) // σημείωση, η τιμή _this_ στη συνάρτηση θα είναι undefined.
// Output: 42
```

Η πρώτη είναι πιο χαμηλού επιπέδου και επιτρέπει τον καθορισμό της τιμής _this_, ενώ η δεύτερη κάνει τη συνάρτηση να μοιάζει με
κανονική συνάρτηση Go.

Αντιστοίχιση ονομάτων πεδίων και μεθόδων struct
------------------------------------------------
Από προεπιλογή, τα ονόματα περνούν ως έχουν, που σημαίνει ότι είναι με κεφαλαία. Αυτό δεν ταιριάζει με
την τυπική σύμβαση ονοματοδοσίας JavaScript, οπότε αν χρειάζεται να κάνετε τον κώδικα JS σας να φαίνεται πιο φυσικός ή αν ασχολείστε
με βιβλιοθήκη τρίτων, μπορείτε να χρησιμοποιήσετε έναν [FieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#FieldNameMapper):

```go
vm := goja.New()
vm.SetFieldNameMapper(TagFieldNameMapper("json", true))
type S struct {
    Field int `json:"field"`
}
vm.Set("s", S{Field: 42})
res, _ := vm.RunString(`s.field`) // χωρίς τον mapper θα ήταν s.Field
fmt.Println(res.Export())
// Output: 42
```

Υπάρχουν δύο τυπικοί mappers: [TagFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#TagFieldNameMapper) και
[UncapFieldNameMapper](https://pkg.go.dev/github.com/dop251/goja#UncapFieldNameMapper), ή μπορείτε να χρησιμοποιήσετε τη δική σας υλοποίηση.

Native Constructors
-------------------

Για να υλοποιήσετε μια συνάρτηση constructor στο Go χρησιμοποιήστε `func (goja.ConstructorCall) *goja.Object`.
Δείτε την τεκμηρίωση του [Runtime.ToValue()](https://pkg.go.dev/github.com/dop251/goja#Runtime.ToValue) για περισσότερες λεπτομέρειες.

Κανονικές Εκφράσεις
-------------------

Το Goja χρησιμοποιεί την ενσωματωμένη βιβλιοθήκη regexp του Go όπου είναι δυνατόν, διαφορετικά επιστρέφει στο [regexp2](https://github.com/dlclark/regexp2).

Εξαιρέσεις
----------

Οποιαδήποτε εξαίρεση που ρίχνεται στο JavaScript επιστρέφεται ως σφάλμα τύπου *Exception. Είναι δυνατό να εξαχθεί η τιμή που ρίχτηκε
χρησιμοποιώντας τη μέθοδο Value():

```go
vm := goja.New()
_, err := vm.RunString(`

throw("Test");

`)

if jserr, ok := err.(*Exception); ok {
    if jserr.Value().Export() != "Test" {
        panic("wrong value")
    }
} else {
    panic("wrong type")
}
```

Αν μια native συνάρτηση Go κάνει panic με ένα Value, ρίχνεται ως εξαίρεση Javascript (και επομένως μπορεί να πιαστεί):

```go
var vm *Runtime

func Test() {
    panic(vm.ToValue("Error"))
}

vm = goja.New()
vm.Set("Test", Test)
_, err := vm.RunString(`

try {
    Test();
} catch(e) {
    if (e !== "Error") {
        throw e;
    }
}

`)

if err != nil {
    panic(err)
}
```

Διακοπή
-------

```go
func TestInterrupt(t *testing.T) {
    const SCRIPT = `
    var i = 0;
    for (;;) {
        i++;
    }
    `

    vm := goja.New()
    time.AfterFunc(200 * time.Millisecond, func() {
        vm.Interrupt("halt")
    })

    _, err := vm.RunString(SCRIPT)
    if err == nil {
        t.Fatal("Err is nil")
    }
    // το err είναι τύπου *InterruptError και η μέθοδος Value() του επιστρέφει ό,τι έχει περάσει στο vm.Interrupt()
}
```

Συμβατότητα με NodeJS
---------------------

Υπάρχει ένα [ξεχωριστό έργο](https://github.com/dop251/goja_nodejs) που στοχεύει στην παροχή κάποιας από τη λειτουργικότητα του NodeJS.